/* ===================== ГЛОБАЛЬНЕ СИДАННЯ СТИЛІВ */
h1,
h2,
h3,
h4,
h5,
h6,
p {
  margin-top: 0;
  margin-bottom: 0;
}

ul,
ol {
  margin-top: 0;
  margin-bottom: 0;
  padding-left: 0;
}

body {
  font-family: sans-serif;
  line-height: 1.5;
  color: #d75a00;
}
.box {
  box-sizing: border-box;
  width: 150px;
  height: 150px;

  border: 5px solid #f44336;
  padding: 30px;
  margin-bottom: 30px;
  background-color: #ffeb3b;
}

.text {
  padding-top: 20px;
  padding-left: 80px;
  padding-bottom: 15px;

  background-color: #eafac7;
  border: 2px dashed #212121;
  margin-bottom: 30px;
}
/* MARGIN */
*,
*::before,
*::after {
  box-sizing: border-box;
}

body {
  font-family: sans-serif;
  line-height: 1.5;
  color: #212121;
}

img {
  display: block;
  max-width: 100%;
  height: auto;
}

.post {
  padding: 20px;

  max-width: 400px;
  background-color: #fff;
  border: 2px dashed #2a2a2a;
}

.post-thumb {
  margin-bottom: 30px;
  border: 2px dashed tomato;
}

.post-heading {
  margin-top: 0;
  margin-bottom: 20px;

  border: 2px dashed teal;
}

.post-text {
  margin-bottom: 0;
  margin-top: 0;

  border: 2px dashed blue;
}

/* ===================== ГЛОБАЛЬНЕ СИДАННЯ СТИЛІВ */
h1,
h2,
h3,
h4,
h5,
h6,
p {
  margin-top: 0;
  margin-bottom: 0;
}

ul,
ol {
  margin-top: 0;
  margin-bottom: 0;
  padding-left: 0;
}

/* Обнулення маржина body вже є певним «стандартом» сучасної розробки, то ж нормалізатор modern-normalize містить цей крок. Тому, якщо на вашій веб-сторінці застосовується нормалізатор,, обнуляти маржин body у своєму коді не потрібно. */

/* =========BORDER============= */

.box-1 {
  width: 300px;
  height: 300px;
  border: 5px dotted #d75a00;
}

/* ==========border-*=================== */
/*Також є властивості, що окремо задають значення рамки. Їх можна застосовувати в якості альтернативи властивості border, або щоб при зміні лиш одного значення рамки не дублювати інші властивості.


border-width: значення;
border-style: значення;
border-color: значення; */

.box-1:hover {
  border-color: aqua;
}

/* Індивідуальні рамки */

.box-1 {
  width: 200px;
  height: 200px;

  border-top: 1px solid blue;
  border-right: 5px dotted black;
  border-bottom: 4px double palevioletred;
  border-left: 9px dashed green;
}
/* ============Заокруглена рамка================ */
/* body {
  padding: 10px;
  display: flex;
  flex-direction: column;
  gap: 10px;
} */

.box-2 {
  width: 280px;
  height: 160px;
  border-radius: 10px;
  background-color: #f44336;
  margin-top: 30px;
}

.box-3 {
  width: 200px;
  height: 200px;
  border-radius: 20%;
  background-color: #2196f3;
  margin-top: 30px;
}

.box-4 {
  width: 240px;
  height: 240px;
  border-radius: 50%;
  background-color: #4caf50;
  margin-top: 30px;
}

/* individual border corner rounding */
/*  
border-top-left-radius:
border-top-right-radius: 
border-bottom-right-radius: 
border-bottom-left-radius:*/

/* ===============Заокруглене зображення====================== */
* {
  box-sizing: border-box;
}

img {
  display: block;
  max-width: 100%;
}

.thumb {
  border: 10px solid green;
  border-radius: 50px;
  width: 480px;

  overflow: hidden;
}

/*       <!-- Властивість overflow -->

<!--overflow: visible | hidden | scroll | auto  --> 

visible - by default
hidden - ховає текст. Ніколи не задавай текстовому блоку властивість "height"
scroll - скролить приховану інфу з двома скролбарами
Auto - скролить з потрібним скролбаром */

/* Типи елементів */
/* DISPLAY є блокові(block) та рядкові (inline)*/
/* Рядкові елементи призначені для виділення та оформлення текстового контенту. Наприклад посилань кнопок, зображень тощо.
Блокові елементи використовуються для розмітки текстових контейнерів (заголовків, списків, абзаців) і великих смислових розділів (секцій, шапки, підвалу). */
/* Блокові елементи можуть бути візуально представлені, як прямокутні області, що йдуть одна за одною зверху вниз.
Для них задано властивість display: block. 
Вони займають всю доступну ширину рядка всередині батьківського елемента.
Їхня висота визначається вмістом, якщо явно не задана у властивості height.
Вони завжди починаються з нового рядка, тому кілька сусідніх блокових елементів розташовані вертикально один під одним.
Їм можна задавати будь-які властивості геометрії елемента: ширину, висоту, падінги, рамки та маржини.
Переважна більшість елементів – блокові. Наприклад <h1>, <p>, <section>, <ul>, <li>, <div>, <header> тощо.*/

/* +++++++++++++++++++++++++++++++++++++Фіксована ширина++++++++++++++++++++++++++++++++++++

Навіть якщо ширину блокових елементів задано явно, елементи все одно розташовуватимуться вертикально один під одним. Усе вільне місце в рядку за замовчуванням займає автоматичний правий відступ (margin-right) елемента. */
body {
  background-color: #f9f9fd;
}

.box {
  /* width: 240px; граємось з шириною блока */
  width: 1000px;
  /* width: 70%; граємось з шириною блока */
  height: 80px;
}

.indigo {
  background-color: #3f51b5;
}

.green {
  background-color: #4caf50;
}

.amber {
  background-color: #ffc107;
}

/* Колапсування вертикальних маржинів */
.box-6 {
  width: 200px;
  height: 100px;
}

.top {
  margin-bottom: 10px;
  background-color: teal;
}

.bottom {
  margin-top: 20px;
  background-color: palevioletred;
}

/* ===============================Горизонтальне центрування блокових елементів ==========================================*/
/* За замовчуванням блоковий елемент має автоматичний правий маржин, який займає все вільне місце в рядку. */
/* Якщо задати автоматичні лівий і правий маржини, вільний простір розподіляється між ними, і блочний елемент центрується. */
body {
  background-color: #f9f9fd;
  font-family: sans-serif;
  line-height: 1.5;
  color: #fff;
  font-size: 20px;
}

.parent {
  background-color: #3f51b5;
}

.child {
  max-width: 220px;
  /* max-width: 1000px; граємось з шириною блока*/
  margin: 0 auto;
  background-color: #4caf50;
  text-align: center;
}

.parent,
.child {
  padding: 20px;
  border-radius: 4px;
}
/* ====================== VIEWPORT======================= */
/* ==================Елемент-контейнер. Тег div ============================*/
/* <div class="container"></div> */
/* .container {
  width: 480px;
  margin: 0 auto;
  padding: 0 15px;
} */
body {
  font-family: sans-serif;
  line-height: 1.5;
  background-color: #f9f9fd;
  color: #212121;
}

.container {
  max-width: 480px;
  margin: 0 auto;
  padding: 0 15px;

  border: 1px dashed #2a2a2a;
}
/* риклад з кількома контейнерами */
body {
  margin: 0;
  font-family: sans-serif;
  line-height: 1.5;
  background-color: #f9f9fd;
}

h1,
h2,
p {
  margin: 0;
}

.container {
  max-width: 480px;
  margin: 0 auto;
  padding: 0 15px;

  outline: 2px dashed #f44336;
}

.page-header,
.page-footer,
.hero,
.about,
.features {
  padding-top: 20px;
  padding-bottom: 20px;
}

.page-header {
  background-color: #e0e0e0;
}

.hero {
  background-color: #4caf50;
}

.about {
  background-color: #ffc107;
}

.features {
  background-color: #2196f3;
}

.page-footer {
  background-color: #90a4ae;
}
/* ===================================Рядкові елементи (inline)====================================== */
/* Для рядкових елементів задається властивість display: inline.
Їхня ширина та висота залежать тільки від вмісту, явно задати їх не можна. Тобто властивості width і height не мають жодного ефекту.
Вони розташовуються в рядку, доки в ньому є достатньо місця, після чого нові елементи переносяться на наступний рядок.
Їм можна задавати лише горизонтальну геометрію: ліві та праві маржини, падінги та рамки. Тобто вони ігнорують значення верхніх і нижніх 'margin', 'padding' і border. */
.link {
  background-color: tomato;
  color: white;

  /* ✅ Працює */
  padding-left: 20px;
  padding-right: 20px;
  margin-right: 50px;
  margin-left: 50px;

  /* ❌ Ніякого ефекта */
  width: 1000px;
  height: 1000px;
  margin-top: 100px;
  margin-bottom: 100px;
}
/* Вертикальні падінги та рамки */
/* вони ніяк не впливають на геометрію сусідніх елементів і тому не використовуються 🤷‍♂️. */

/* Рядково-блокові елементи (inline-block) */
/* Для них задана властивість display: inline-block.
Їх ширина і висота залежать від вмісту, але можна явно задати властивості width і height.
Вони розташовуються в рядку доти, поки в ньому є достатньо місця, після чого нові переносяться на наступний рядок.
Їм можна задавати будь-які властивості геометрії елемента: ширину, висоту, поля, рамки та відступи.

Рядково-блокові елементи використовуються в тих випадках, коли рядковим елементам потрібно додати декоративні ефекти.

Приклади таких задач:
-Задати для посилання вертикальні падінги, маржини або ширину з висотою, візуально зробивши з неї кнопку;
-Перетворити <span> на іконку з фіксованими розмірами. */
.link-1 {
  display: inline-block;
  padding: 16px 32px;

  border-radius: 3px;
  background-color: teal;
  color: white;

  font-family: sans-serif;
  font-size: 14px;
  text-decoration: none;
  text-transform: uppercase;
  font-weight: 700;
  margin-top: 50px;
}

/* Проміжок рядкових елементів */
/* У рядкових та рядково-блочних елементів є правий проміжок.
Величина цього проміжку визначається:
розміром тексту найближчого батьківського елемента з явно визначеним значенням
Або
якщо такого батьківського елемента немає, використовується розмір шрифту від браузера за замовчуванням - 16px.
Тому у кнопок, посилань, зображень, спанів і інших рядкових елементів за умовчанням буде проміжок 4px — 1/4 розміру шрифту найближчого батьківського елемента. */

/* Приховані елементи */
/* Значення display: none дозволяє повністю приховати елемент, звільнивши його простір для інших. Такий елемент вилучається з потоку документа, візуально приховується й відсутній у розкладці сторінки.

Мінус цього підходу в тому, що зміну значення властивості display не можна анімувати, але для цього є інші підходи, з якими познайомимося пізніше.

Наберемо просту розмітку панелей (табів), що перемикаються. З цих панелей повинна відображатися тільки одна — активна панель. */

/* +++++++++++++++++++Зображення++++++++++++++++++++ */
/* Аби не дублювати зміну типу елемента для кожного зображення та раз і назавжди прибрати нижній проміжок, задамо глобальні стилі тегу img, зробивши його блоковим. Це вирішує проблему.. Та й взагалі, на практиці, при роботі із зображеннями їх завжди роблять блоковими.

img {
	display: block;
} */
*,
*::before,
*::after {
  box-sizing: border-box;
}

body {
  font-family: sans-serif;
  line-height: 1.5;
  background-color: #f9f9fd;
}

img {
  display: block;
}

.card {
  max-width: 320px;
  margin: 0 auto;
  border-radius: 4px;
  overflow: hidden;
  background-color: #f44336;
  box-shadow: 0px 2px 1px -1px rgba(0, 0, 0, 0.2),
    0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12);
}

.card-image {
  max-width: 100%;
}

.card-heading {
  margin: 0;
  padding: 20px;
  font-weight: 500;
  background-color: #03a9f4;
}

.card + .card {
  margin-top: 20px;
}

/* Властивість max-width */

/* .card-image {
  max-width: 100%;
} */

/* Які наслідки будуть, якщо закоментувати max-width: 100%; у властивості .card-image? 

Зображення буде рендеритися у своєму оригінальному розмірі, виходячи за рамки батьківського елемента. */

/* Гумові зображення */
/* За замовчуванням зображення відображається у своєму оригінальному розмірі. Отже, якщо атрибути розміру для тега img не вказані, зображення виходить за рамки батьківського елемента з фіксованою шириною (див. схему нижче). Таке буває, коли ширина зображення не вказується жорстко й залежить від ширини батьківського елемента. */
/* Для того, щоб зображення, для якого явно не задано ширину, автоматично підлаштовувалося під ширину батьківського елемента,

додаємо йому властивість максимальної ширини max-width;
задаємо для цієї властивості значення 100%;
всі ці налаштування робимо у глобальних стилях із селектором тега img, щоб застосувати до всіх зображень на сторінці. */

/* img {
	display: block;
	max-width: 100%;
}

Це зробить зображення «гумовими», тобто вони підлаштовуватимуться під ширину батьківського елемента, зменшуватимуться чи збільшуватимуться, але ніколи не будуть ширшими ніж свій оригінальний розмір, аби не втратити якість. */

/* Якщо потрібно явно задати ширину та висоту зображення, то властивість max-width просто не матиме жодного ефекту і не завадить. */

/* Властивість object-fit */
/* Трапляються ситуації, коли зображення має інші розміри чи пропорції, ніж контейнер, у який його необхідно помістити.

В ці контейнери необхідно красиво вмістити світлини товарів довільного розміру, тобто підігнати картинку під контейнер.
Pображення можна обрізати, розтягувати чи масштабувати.

object-fit: 
| fill -зображення масштабується без збереження пропорцій, щоб повністю заповнити контейнер. Значення за замовчуванням.

| contain -зображення масштабується зі збереженням пропорцій, щоб максимально заповнити контейнер.

| cover -зображення масштабується зі збереженням пропорцій, щоб повністю заповнити контейнер.

| scale-down -буде вибрано значення none або contain, щоб зображення було найменшого розміру. Мета — вмістити все зображення без зміни пропорцій.

| none -зберігаються вихідні розміри зображення, задана висота та ширина не мають жодного ефекту.

На практиці найкориснішим значенням є ========cover========== , тому що зображення повністю заповнює контейнер за висотою та шириною, при цьому зберігає пропорції. В інших випадках зображення спотворюється чи не заповнює контейнер.
*/

/* Розташування зображення в контейнері фіксованого розміру */

/* Для того, щоб ця техніка працювала, необхідні два обов'язкові кроки.


<div class="thumb">
  <img src="" alt="" />
</div>

Перший: контейнеру має бути явно задано фіксовану висоту. Ширина може бути за шириною батьківського елемента, як у живому прикладі.

.thumb {
  height: 400px;
  width: 300px;
}

Другий: зображення необхідно «вмістити» в контейнер, задавши img висоту та ширину 100%, і вказати object-fit.

.thumb img {
  height: 100%;
  width: 100%;
	object-fit: cover;
}
Можна не використовувати контейнер, задавши фіксовані розміри самому елементу img, але найчастіше трапляється саме така розмітка. Елемент контейнера використовується для створення анімацій та інших декоративних ефектів, пов'язаних з областю зображення. */

/* =====================Flexbox =======================*/
/* Flexbox-контейнер може:

змінювати ширину і висоту його дітей;
змінювати напрямок розташування його дітей (вирівнювання в колонку або рядок);
змінювати порядок відображення елементів та відстань між ними;
розширювати елементи, щоб оптимально заповнити доступний простір;
стискати елементи, щоб запобігти переповненню.


У flex-контейнері скасовується більшість правил розташування елементів відповідно до їх типу та потоку документа. 
— Елементи втрачають «тип», перестають бути рядковими або блоковими, вони стають flex-елементами.
— Блокові елементи перестають йти вертикально один під одним.
— Маржини елементів на краю батьківського елементу не випадають.
— Вертикальні маржини не схлопуються.
— Працюють автоматичні вертикальні відступи. */

/* У моделі Flexbox напрямок розташування елементів визначається направляючими осями контейнера, вздовж яких вибудовуються елементи. */
/* Main axis

Main axis — головна вісь flex-контейнера, вздовж якої розміщуються елементи. Напрямок main axis контролюється властивістю flex-direction. Вона може бути:


горизонтальною (sample A)
вертикальною (sample B) */

/* Модель Flexbox має точки "start" та "end" для визначення порядку елементів всередині flex-контейнера.

Осі (main axis, cross axis) визначають лінії вздовж яких розташовуються елементи.
Точки "start" та "end" — це буквально точки початку та кінця на головній або поперечній осі. Саме вони визначають де буде перший, а де останній елемент по осі. */

/* Не слід думати, що старт — це завжди зверху ліворуч, а фініш — завжди внизу праворуч. Будь-який порядок елементів можна налаштувати — зліва направо чи справа наліво, зверху вниз чи знизу вверх. Точки start та end прямо залежать від напрямку осей. */

/* Flex-контейнер (далі просто контейнер) — це батьківський елемент групи елементів, який дозволяє змінити порядок розташування елементів усередені. Саме властивості контейнера контролюють: 
напрямок осей,
багаторядковість і
позиціонування елементів у рядку. */

/* ====================Властивість display======================= */

/* Властивість display створює flex-контейнер: блоковий або рядково-блоковий.

display: flex | inline-flex

Залежно від заданого значення, властивість установлює flex-контекст для всіх дітей (не нащадків) контейнера, перетворюючи їх на flex-елементи.

<ul class="menu">
  <li class="item"><a href="" class="link">Головна</a></li>
  <li class="item"><a href="" class="link">Блог</a></li>
  <li class="item"><a href="" class="link">Подкасти</a></li>
  <li class="item"><a href="" class="link">Контакти</a></li>
</ul> */

/* Властивість gap */
/* .menu {
  display: flex;
	gap: 8px;
} */

/* Властивість flex-direction

Flexbox — це система розташування елементів в одному напрямку: горизонтально чи вертикально. Властивість flex-direction задає напрямок головної осі, а отже визначає напрямок елементів у контейнері. */

/* flex-direction: row | row-reverse | column | column-reverse
За замовчуванням для flex-direction встановлено значення row, тому в прикладі елементи верхнього меню розташовані зліва направо. */

/* Властивість justify-content

Властивість justify-content керує позиціонуванням елементів на головній осі, від main-start до main-end.

flex-start — елементи притискаються до точки main-start головної осі. 
              Це значення за замовчуванням.
flex-end    — елементи притискаються до точки main-end головної осі.
      center — елементи центруються на осі.
space-between — елементи рівномірно розподіляються на головній осі. Перший елемент встановлюється на початок осі, а останній на кінець.
space-around — елементи розподіляються рівномірно, але лівий та правий елементи розташовані на відстані від рамок контейнера на половину проміжку між іншими елементами.
space-evenly — елементи розподіляються так, що відстань між елементами та від крайніх елементів до меж контейнера однакова. */

/* Властивість align-items */
/* Властивість align-items керує розташуванням елементів вздовж поперечної осі cross axis. Це аналог justify-content тільки для іншої осі.


align-items: stretch | flex-start | flex-end | center | baseline */

/* Властивість flex-wrap

За замовчуванням display: flex створює однорядковий контейнер, елементи розміщуються на одному рядку й за потреби стискаються.

Властивість flex-wrap дозволяє перетворити однорядковий контейнер на багаторядковий. Елементи будуть додаватися в рядок, доки в ньому буде місце, після чого буде автоматично створено ще один рядок.

Властивість flex-wrap має такі значення:

flex-wrap: nowrap | wrap | wrap-reverse */

/* ==============================Властивості елементів ========================*/

/* Flex-елементи

Flex-елементи — це діти flex-контейнера, елементи першого рівня вкладеності.

У моделі Flexbox flex-елементи (далі просто елементи):

перестають підкорятися стандартному потоку документа;
втрачають свій тип (блоковий, рядковий, тощо) та
дотримуються правил позиціонованої Flexbox-моделі. */

/* =============Властивість flex-basis===============

flex-basis: auto | значення*/
/* Якщо застосовано обидві властивості, flex-basis і width, то властивість width ігнорується.
Властивість flex-basis може визначати висоту, а не ширину елемента. Це відбувається, коли напрямок головної осі вертикальний.
Властивості min-width і max-width працюють, як обмежувачі розміру елемента, навіть якщо у нього вказано flex-basis.
Властивість flex-basis — це не фінальний розмір елемента, а розмір до розподілу вільного простору, який регулюється властивостями flex-grow і flex-shrink. */

/* =================flex-grow ====================*/
/* Властивість flex-grow — визначає здатність елемента займати більше місця (рости), ніж початковий розмір. Значення визначається як пропорція (частка) вільного місця в контейнері.



flex-grow: частка

За замовчуванням у всіх елементів встановлено значення 0. Тобто за замовчуванням елементи не намагаються зайняти додаткове вільне місце, навіть якщо таке є. Негативні значення задавати не можна.

Важливо не те, яке значення flex-grow елемента саме по собі, а те, яке воно по відношенню до інших елементів.

Якщо ми встановимо для кожного елемента значення flex-grow: 1, а потім змінимо flex-grow для третього елемента, то побачимо зміни: він займе у 2, 3 та 6 разів більше місця у рядку, ніж інші елементи. */

/* ========================Гумовий контент============================ */
/* Типовий випадок використання цієї властивості — сайдбар фіксованої ширини та «гумовий» контент, який займає в рядку все вільне місце, що залишилося.



<div class="container">
  <aside class="sidebar">Sidebar</aside>
  <main class="content">Main content</main>
</div>



Якщо зробити div.container flex-контейнером, то сайдбар займе фіксовану ширину в рядку, а ширина main.content визначатиметься шириною його вмісту.






Все, що необхідно — це задати main.content властивість flex-grow: 1 , аби контейнер зайняв усе доступне вільне місце в рядку.

Вивчи приклад, аби побачити як це реалізовано. */

/* ==============Приклеєний футер сторінки====================



Ще один частий випадок застосування властивості flex-grow — необхідність притиснути футер сторінки до її низу, незалежно від обсягу її основного вмісту.



<header>Page header</header>
<main>Main content</main>
<footer>Page footer</footer>



Якщо вмісту main достатньо, то сторінка може виглядати так: зверху хедер, потім основний вміст і внизу сторінки футер. */
/* Як реалізувати приклеєний футер сторінки?



Для реалізації нам знадобиться додатковий елемент-обгортка.



<div class="page-container">
	<header>Page header</header>
	<main>Main content</main>
	<footer>Page footer</footer>
</div>



Перше, що зробимо, — задамо йому мінімальну висоту 100% висоти вкладки браузера на екрані користувача, використовуючи одиниці vh (viewport height — відсоток від висоти області перегляду 5vh = 5% висоти).



.page-container {
	min-height: 100vh;
}



Далі перетворимо його на flex-контейнер і змінимо напрямок головної осі на вертикальний, тобто зверху вниз. Це змусить flex-елементи розташовуватись у стовпчик.



.page-container {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}



Залишилося задати main властивість flex-grow, щоб дозволити йому займати все вільне місце на головній осі, відсуваючи «футер» у її кінець, тобто вниз.



main {
  flex-grow: 1;
}



Тепер, не залежно від того, скільки вмісту в main, він завжди займає все вільне місце на головній осі, яке залишилося після футера і хедера. */

/*  ======================flex-shrink========================

На противагу властивості flex-grow, flex-shrink визначає здатність flex-елемента займати менше місця (стискатися), ніж його початковий розмір, тобто впливає на фінальний розмір елемента.

flex-shrink: значення;

Значення задається у вигляді пропорції (частка, фактор).

За замовчуванням у всіх елементів встановлено значення 1, тобто елементи стискатимуться за потреби.
Значення 0 заборонить елементу стискатися. Негативні значення задавати не можна.

На практиці flex-shrink зазвичай застосовують, аби заборонити елементу стискатися. Розгляньмо стандартну проблему: контейнер, у ньому два елементи — декоративний, наприклад іконка з фоновим зображенням, і текст. */

/* ====================Властивість align-self==========================

Властивість align-self дозволяє елементу змінити своє розташування на cross axis, перевизначивши собі значення властивості align-items від контейнера.

align-self: auto | flex-start | flex-end | center | baseline | stretch


Аналога для main axis немає, й елемент може змістити себе лише з поперечної осі.

Повернімося до прикладу картки із зображенням і текстовим вмістом.

Для вирішення проблеми вертикального розтягування картинки ми використовували властивість контейнера align-items. Властивість align-self дозволяє вирішити цю проблему більш точково, перевизначивши значення align-items тільки для зображення.

.card img {
  align-self: flex-start;
} */

/* Псевдокласи :first-child і :last-child



Псевдокласи :first-child і :last-child дозволяють скласти селектор, який застосовується лише до першого чи останнього елемента в колекції сусідніх елементів. */

.list {
  padding: 0;
  margin: 0;
  list-style: none;
}

.list-item {
  padding: 4px;
  background-color: #228be6;
}

.list-item {
  margin-bottom: 20px;
  text-align: center;
}

.list-item:last-child {
  margin-bottom: 0;
}

/* Псевдоклас :not()



Псевдоклас :not() дозволяє вибрати всі елементи, що не підходять під критерій.

Критерій вказується у вигляді простого селектора, записаного в дужках. Простий селектор — це універсальний селектор, селектор типу, ідентифікатора, атрибута, класу чи псевдокласу.



:not(selector)



Цей псевдоклас можна застосувати для того, щоб по-іншому вирішити задачу очищення крайнього маржина першого чи останнього елемента.

Замість того, щоб в одному правилі задавати відступ всім, а потім не забути в іншому його обнулити для конкретного елемента, ми в одному правилі задаємо відступ усім елементам, крім одного.



.list-item:not(:last-child) {
  margin-bottom: 20px;
}
Читається як:

застосувати стилі до всіх елементів із класом list-item, які не є останнім елементом у колекції сусідів. Тобто такий селектор застосовується до всіх елементів колекції, крім останнього. */

.list-item:nth-child(2n) {
  background-color: orange;
}

/* Аналогічно використовуючи псевдонім */
/* .list-item:nth-child(even) {
  background-color: orange;
} */
